name: validate-pr-metadata

on:
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review]

jobs:
  metadata:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate PR metadata fields and semantics
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.pull_request.body || "";

            function fail(msg) {
              core.setFailed(msg);
            }

            const required = [
              "Issue-ID:",
              "MP-ID:",
              "Runbook:",
              "Base-Commit:",
              "Classification:",
              "Compatibility:",
              "## Evidence",
              "## Commands run"
            ];
            const missing = required.filter((k) => !body.includes(k));
            if (missing.length) {
              return fail(`Missing required PR fields: ${missing.join(", ")}`);
            }

            const banned = ["#<issue-number>", "<40-char-sha>", "MP-<TRACK>-<X.Y.Z>", "docs/runbooks/<name>.md#<anchor>"];
            const unresolved = banned.filter((x) => body.includes(x));
            if (unresolved.length) {
              return fail(`Unresolved placeholders in PR body: ${unresolved.join(", ")}`);
            }

            const extract = (label) => {
              const re = new RegExp(`${label}\\s*:\\s*([^\\n\\r]+)`, "i");
              const m = body.match(re);
              return m ? m[1].trim() : "";
            };

            const issue = extract("Issue-ID");
            if (!/^#\d+$/.test(issue) && !/^N\/A$/i.test(issue)) {
              return fail("Issue-ID must be #<number> or N/A.");
            }
            if (/^N\/A$/i.test(issue)) {
              const reasonMatch = body.match(/Issue-Reason[^:\n\r]*:\s*([^\n\r]+)/i);
              const reason = reasonMatch ? reasonMatch[1].trim() : "";
              if (!reason || /<required/i.test(reason)) {
                return fail("Issue-ID is N/A but Issue-Reason is missing.");
              }
            }

            const mp = extract("MP-ID");
            if (!/^N\/A$/i.test(mp) && !/^MP-[A-Z0-9-]+-\d+\.\d+\.\d+$/.test(mp)) {
              return fail("MP-ID must be MP-<TRACK>-<X.Y.Z> or N/A.");
            }

            const runbook = extract("Runbook");
            if (!/^N\/A$/i.test(runbook) && !/^docs\/runbooks\/.+\.md#.+$/.test(runbook)) {
              return fail("Runbook must be docs/runbooks/<name>.md#<anchor> or N/A.");
            }

            const base = extract("Base-Commit");
            if (!/^[0-9a-f]{40}$/i.test(base)) {
              return fail("Base-Commit must be a 40-char SHA.");
            }

            const evidenceMatch = body.match(/## Evidence\s*([\s\S]*?)(?:\n##\s|$)/i);
            const evidence = evidenceMatch ? evidenceMatch[1].trim() : "";
            if (!evidence) {
              return fail("Evidence section cannot be empty.");
            }
            if (/(\bTODO\b|\bTBD\b|to be done|lorem ipsum)/i.test(evidence)) {
              return fail("Evidence contains placeholder/TODO text.");
            }

            if (!/## Commands run\s*[\s\S]*```bash[\s\S]*```/i.test(body)) {
              return fail("Commands run must include a bash fenced code block.");
            }

            core.info("PR metadata validation passed.");

      - name: Validate runbook path and anchor (if provided)
        shell: bash
        run: |
          set -euo pipefail
          BODY_FILE="$(mktemp)"
          cat > "$BODY_FILE" <<'PR_BODY'
          ${{ github.event.pull_request.body }}
          PR_BODY

          runbook="$(sed -nE 's/.*Runbook:[[:space:]]*([^[:space:]].*)/\1/p' "$BODY_FILE" | head -n1 | tr -d '\r')"
          if [[ -z "$runbook" || "$runbook" =~ ^N/A$|^N\/A$ ]]; then
            echo "Runbook is N/A: skipping file/anchor validation"
            exit 0
          fi

          file="${runbook%%#*}"
          anchor="${runbook#*#}"
          if [[ "$file" == "$anchor" || -z "$anchor" ]]; then
            echo "Runbook anchor missing in: $runbook" >&2
            exit 1
          fi

          if [[ ! -f "$file" ]]; then
            echo "Runbook file not found: $file" >&2
            exit 1
          fi

          if ! grep -Eq "id=\"$anchor\"|\(#$anchor\)|^#+[[:space:]].*\{#$anchor\}" "$file"; then
            echo "Runbook anchor not found in $file: #$anchor" >&2
            exit 1
          fi

          echo "Runbook link validated: $runbook"
